# 计网

### http:



http1.0:

​	无连接，

​	队列阻塞（下一个请求必须在前一个到达后才能发送），

​	缓存

Http1.1:

​	长连接，

​	管道传输（不需要等前一个到），

​	更多缓存头，

​	断点续传

http2.0:

​	header压缩，两方各维护一张header表；

​	多路复用：一个链接多个请求；

​	新二进制帧格式，给帧标序号；

​	serverpush：允许服务端推送资源到浏览器，避免客户端重复从服务器通过<u>网络</u>请求某些资源

http3.0:

​	用udp而非tcp实现可靠传输

​	缓存当前会话上下文，快速建立连接

​	多路复用：丢包不需要整个重传

​	所有报文头部均有加密pocketheader加密

​	向前纠错：每个包都还包含了其他包的数据，减少重传次数



http vs https

http明文传输，不加密。80

https基于stl/tls加密（更耗费服务器资源），需要ca申请证书。443



<u>https加密过程</u>

1.clienthello

​	发随机数，支持的stl/tls，密码套件

2.serverhello

​	发随机数，确认stl/tls，密码套件版本，回ca证书

3.客户端回应

​	用ca公钥确认证书真实性

​	发随机数

​	转换到加密模式

​	握手结束通知

​	总结刚才的工作

4.服务器回应

​	通过上述三个随机数计算出本次<u>会话密钥</u>

​	转换到加密模式

​	握手结束确认

​	总结刚才工作

### TCP UDP

##### tcp如何保证可靠传输

1.连接管理（握手挥手）

2.拥塞控制（慢启动，拥塞避免）

3.快速重传

4.校验和，序列号

5.流量控制



##### 慢启动：

cwnd = 1，每个ack+1

一个rtt未丢包，*2

到ssthresh或重传，拥塞避免

##### 拥塞避免：

cwnd+=1/cwnd

发生丢包或重传，拥塞控制

##### 拥塞控制：

ssthresh = cwnd/2

cwnd = 1

收到3个一样的ack后开始快速重传

##### 快速重传

cwnd = cwnd/2

ssthresh = cwnd

进入快速恢复

##### 快速恢复

cwnd = ssthresh + 3

再重复，cwnd + 1

收到新的ack后，重新拥塞避免



##### 三次握手：

​	确认对方有接受/发送能力

​	丢失：

​		前两次：回syn

​		第三次：服务端回syn+ack

##### 四次挥手

​	1.客户端fin1 ack seq 进fin_wait1，超时重传fin

​	2.服务器ack1（处理数据）进close_wait，客户端fin_wait2

​	3.服务器fin1，last_ack，丢：不断fin1，进last_ack

​	4.客户端ack1，进time_wait（2msl）

##### ###丢失：都会触发超时重传

##### TIME_WAIT作用：

可靠关闭连接：展示关闭连接的“意图”，防止因延迟造成的数据丢失

防止旧连接重新利用



##### ARP：解析mac地址

客户端将含自己的ip，mac，对方ip，mac为空的报文广播

服务端收到后对一下自己的ip，正确后返回客户端ipmac，还有自己的mac，用私发



##### cookie和session：

cookie：客户端保存信息（登陆状态，会话状态，密码。。。

session：服务器保存会话



##### ping过程

ping创建icmp echo request包，发送到目标ip

目标收到后建icmp echo reply，发送回发送端

发送端检查reply信息，计算rtt

显示



##### 访问网站过程

键盘输入

url解析

创建tcp连接

创建http连接

返回到浏览器

渲染显示



##### dns过程

客户机->本地dns（自查）

本地dns->根dns（上查）

根dns将对应顶级dns->根dns->本地dns（返回）

本地dns->顶级dns

顶级将授权服务器->本地

本地->授权

授权将返回结果->本地



100：提示信息，中间状态

200:服务器**成功**处理了客户端的请求。

300:重定向

400:客户端错误

500:服务端错误



100类状态码属于**提示信息**，是协议处理中的一种中间状态，实际用到的比较少。

- 100(继续)：请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。
- 101(切换协议）：请求者已要求服务器切换协议，服务器已确认并准备切换。

200类状态码表示服务器**成功**处理了客户端的请求。

- 200(成功）：表示服务器**响应成功**，也就是服务器找到了客户端请求的内容，并且将内容返回给客户端。
- 204(已创建）：请求成功并且服务器创建了新的资源。
- 206(部分内容）：服务器成功处理了部分GET请求。

300类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是**重定向**。

- 301(永久移动）：代表永久性的重定向**，值得注意的是，这种重定向跳转，从严格意义来讲不是服务器跳转，而是客户端跳转**的。这个“跳”的动作是服务器是通过回传状态码301来下达给客户端的，让客户端完成跳转。
- 302(临时移动）：代表**临时跳转**。例如：URL地址A可以向URL地址B上跳转，但这并不是永久性的，在经过一段时间后，URL地址A还可能向URL地址C上跳转。
- 304(未修改）：服务器通过返回状态码304可以告诉客户端请求资源成功，但是这个资源不是由服务器提供返回给客户端的，而是客户端本地浏览器缓存中就有的这个资源，因为可以从缓存中获取这个资源，从而节省传输的开销。
- 400类状态码表示客户端发送的**报文有误**，服务器无法处理。
- 400(错误请求）：服务器不理解请求的语法。
- 403(禁止）：代表请求的服务器资源**权限不够**，也就是没有权限去访问服务器的资源，或者请求的IP地址被封掉了。
- 404(未找到）：代表服务器上**没有该资源**，或者说服务器找不到客户端请求的资源，是最常见的请求错误码。

500类状态码表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于服务器端的错误码。

- 500(服务器内部错误）：代表**程序错误**，也就是说请求的网页程序本身报错了。在服务器端的网页程序出错。由于现在的浏览器都会对状态码500做一定的处理，所以在一般情况下会返回一个定制的错误页面。
- 501(尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。
- 502(错误网关）：通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
- 503(服务不可用）：表示服务器当前很忙，暂时无法响应客户端。。
- 504(网关超时）：服务器作为网关或代理，但是没有及时从上游服务器收到请求。
- 505(HTTP 版本不受支持）：服务器不支持请求中所用的 HTTP 协议版本。

### 浏览器访问网址过程：

**键盘输入**

输入键盘字符后键盘就会产生扫描数据，并将其缓冲存在寄存器中，然后键盘通过总线给 CPU 发送中断请求。CPU 收到中断请求后，操作系统会保存被中断进程的 CPU 上下文，然后调用键盘的中断处理程序。键盘中断处理函数从键盘的寄存器的缓冲区读取扫描码，再根据扫描码找到用户在键盘输入的字符的ASCII 码。然后把 ASCII 码放到读缓冲区队列，显示器会定时从读缓冲区队列读取数据放到写缓冲区队列，最后把写缓冲区队列的数据一个一个写入到显示器的寄存器中的数据缓冲区，最后将这些数据显示在屏幕里。

**URL解析**

浏览器会首先从缓存中找是否存在域名，如果存在就直接取出对应的ip地址，如果没有就开启一个DNS域名解析器。DNS域名解析器会首先访问顶级域名服务器，将对应的IP发给客户端；然后访问根域名解析器，将对应的IP发给客户端；最后访问本地域名服务器，得到最终的ip地址。

**TCP连接**

在URL解析过程中得到真实的IP地址之后，会调用Socket函数建立TCP连接。

**HTTP请求**

浏览器向服务器发起一个 HTTP请求，HTTP协议是建立在TCP协议之上的应用层协议，其本质是建立起的 TCP连接中，按照 HTTP协议标准发送一个索要网页的请求。请求包含请求行、请求头、请求体三个部分组成，有GET、POST等主要方法。

**浏览器接收响应**

服务器在收到浏览器发送的HTTP请求之后，会将收到的HTTP报文封装成HTTP的Request对象，并通过不同的Web服务器进行处理，处理完的结果以HTTP的Response对象返回，主要包括状态码，响应头，响应报文三个部分。

**页面渲染**

浏览器根据响应开始显示页面，首先解析 HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。

**断开连接**

客户端和服务器通过四次挥手终止TCP连接。

​	